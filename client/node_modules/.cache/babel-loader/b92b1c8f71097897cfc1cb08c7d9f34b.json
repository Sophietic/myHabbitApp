{"ast":null,"code":"import moment from 'moment';\nexport const currentRunStreakCalc = (response, setRunStreak) => {\n  let longestRunStreakArray = [];\n  let oneRunStreak = 0;\n  const currentTime = moment().unix();\n\n  for (let i = 0; i < response.data.length; i++) {\n    if (response.data[i + 1] !== undefined) {\n      // oneRunStreak = 1;\n      const prevUpdated = Date.parse(response.data[i].updatedAt);\n      const currentUpdated = Date.parse(response.data[i + 1].updatedAt);\n\n      if (prevUpdated !== Date.parse(response.data[i].createdAt)) {\n        if (currentTime - prevUpdated < 86400) {\n          //defines current run streak: within the day\n          if (currentUpdated - prevUpdated < 86400 && response.data[i].completed === true) {\n            //for every session completed in a 24hr window, add 1 to the runStreak. \n            oneRunStreak++;\n          } else {\n            //else break the run streak, push it to array, and start again at 1.\n            longestRunStreakArray.push(oneRunStreak);\n            oneRunStreak = 0;\n          }\n        }\n      }\n    } else {\n      if (response.data[i].completed === true) {\n        oneRunStreak++;\n      }\n\n      longestRunStreakArray.push(oneRunStreak);\n      oneRunStreak = 0;\n    }\n  }\n\n  const highestRunStreak = Math.max.apply(null, longestRunStreakArray);\n  setRunStreak(highestRunStreak);\n}; //check if working\n\nexport const longestRunStreakCalc = (response, setLongestRunStreak) => {\n  let longestRunStreakArray = [];\n  let oneRunStreak = 0;\n\n  for (let i = 0; i < response.data.length; i++) {\n    if (response.data[i + 1] !== undefined) {\n      const prevUpdated = Date.parse(response.data[i].updatedAt);\n      const currentUpdated = Date.parse(response.data[i + 1].updatedAt);\n\n      if (prevUpdated !== Date.parse(response.data[i].createdAt)) {\n        if (currentUpdated - prevUpdated < 86400) {\n          //seconds 24hrs = 24 * 60 minues * 60 seconds = 86,400 seconds\n          //for every session completed in a 24hr window, add 1 to the runStreak. \n          oneRunStreak++;\n        } else {\n          //else break the run streak, push it to array, and start again at 1.\n          longestRunStreakArray.push(oneRunStreak);\n          oneRunStreak = 1;\n        }\n      }\n    } else {\n      if (response.data[i].completed === true) {\n        oneRunStreak++;\n      }\n\n      longestRunStreakArray.push(oneRunStreak);\n      oneRunStreak = 0;\n    }\n  }\n\n  const highestRunStreak = Math.max.apply(null, longestRunStreakArray);\n  setLongestRunStreak(highestRunStreak);\n};","map":{"version":3,"sources":["/home/sophiepa/ironhack/finalproject/myIronhackProject/client/src/components/streaks/Streaks.js"],"names":["moment","currentRunStreakCalc","response","setRunStreak","longestRunStreakArray","oneRunStreak","currentTime","unix","i","data","length","undefined","prevUpdated","Date","parse","updatedAt","currentUpdated","createdAt","completed","push","highestRunStreak","Math","max","apply","longestRunStreakCalc","setLongestRunStreak"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,QAAnB;AAEA,OAAO,MAAMC,oBAAoB,GAAG,CAACC,QAAD,EAAWC,YAAX,KAA4B;AAC9D,MAAIC,qBAAqB,GAAG,EAA5B;AACA,MAAIC,YAAY,GAAG,CAAnB;AACA,QAAMC,WAAW,GAAGN,MAAM,GAAGO,IAAT,EAApB;;AAEA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGN,QAAQ,CAACO,IAAT,CAAcC,MAAjC,EAAyCF,CAAC,EAA1C,EAA8C;AAC5C,QAAIN,QAAQ,CAACO,IAAT,CAAcD,CAAC,GAAC,CAAhB,MAAuBG,SAA3B,EAAsC;AACpC;AACA,YAAMC,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWZ,QAAQ,CAACO,IAAT,CAAcD,CAAd,EAAiBO,SAA5B,CAApB;AACA,YAAMC,cAAc,GAAGH,IAAI,CAACC,KAAL,CAAWZ,QAAQ,CAACO,IAAT,CAAcD,CAAC,GAAC,CAAhB,EAAmBO,SAA9B,CAAvB;;AAEA,UAAIH,WAAW,KAAKC,IAAI,CAACC,KAAL,CAAWZ,QAAQ,CAACO,IAAT,CAAcD,CAAd,EAAiBS,SAA5B,CAApB,EAA4D;AAC1D,YAAGX,WAAW,GAAGM,WAAd,GAA4B,KAA/B,EAAsC;AAAE;AACpC,cAAGI,cAAc,GAAGJ,WAAjB,GAA+B,KAA/B,IAAwCV,QAAQ,CAACO,IAAT,CAAcD,CAAd,EAAiBU,SAAjB,KAA+B,IAA1E,EAAgF;AAC9E;AACAb,YAAAA,YAAY;AACb,WAHD,MAGO;AACL;AACAD,YAAAA,qBAAqB,CAACe,IAAtB,CAA2Bd,YAA3B;AACAA,YAAAA,YAAY,GAAG,CAAf;AACD;AACJ;AACF;AAEF,KAlBD,MAkBO;AACL,UAAGH,QAAQ,CAACO,IAAT,CAAcD,CAAd,EAAiBU,SAAjB,KAA+B,IAAlC,EAAyC;AACvCb,QAAAA,YAAY;AACb;;AACDD,MAAAA,qBAAqB,CAACe,IAAtB,CAA2Bd,YAA3B;AACAA,MAAAA,YAAY,GAAG,CAAf;AACD;AAEF;;AAED,QAAMe,gBAAgB,GAAGC,IAAI,CAACC,GAAL,CAASC,KAAT,CAAe,IAAf,EAAqBnB,qBAArB,CAAzB;AACAD,EAAAA,YAAY,CAACiB,gBAAD,CAAZ;AACD,CApCM,C,CAsCP;;AACA,OAAO,MAAMI,oBAAoB,GAAG,CAACtB,QAAD,EAAWuB,mBAAX,KAAmC;AACrE,MAAIrB,qBAAqB,GAAG,EAA5B;AACA,MAAIC,YAAY,GAAG,CAAnB;;AAEA,OAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGN,QAAQ,CAACO,IAAT,CAAcC,MAAjC,EAAyCF,CAAC,EAA1C,EAA8C;AAC5C,QAAGN,QAAQ,CAACO,IAAT,CAAcD,CAAC,GAAC,CAAhB,MAAuBG,SAA1B,EAAsC;AACpC,YAAMC,WAAW,GAAGC,IAAI,CAACC,KAAL,CAAWZ,QAAQ,CAACO,IAAT,CAAcD,CAAd,EAAiBO,SAA5B,CAApB;AACA,YAAMC,cAAc,GAAGH,IAAI,CAACC,KAAL,CAAWZ,QAAQ,CAACO,IAAT,CAAcD,CAAC,GAAC,CAAhB,EAAmBO,SAA9B,CAAvB;;AAEA,UAAIH,WAAW,KAAKC,IAAI,CAACC,KAAL,CAAWZ,QAAQ,CAACO,IAAT,CAAcD,CAAd,EAAiBS,SAA5B,CAApB,EAA4D;AAC1D,YAAGD,cAAc,GAAGJ,WAAjB,GAA+B,KAAlC,EAAyC;AACvC;AACA;AACAP,UAAAA,YAAY;AACb,SAJD,MAIO;AACL;AACAD,UAAAA,qBAAqB,CAACe,IAAtB,CAA2Bd,YAA3B;AACAA,UAAAA,YAAY,GAAG,CAAf;AACD;AACF;AAEF,KAhBD,MAgBO;AACL,UAAGH,QAAQ,CAACO,IAAT,CAAcD,CAAd,EAAiBU,SAAjB,KAA+B,IAAlC,EAAyC;AACvCb,QAAAA,YAAY;AACb;;AACDD,MAAAA,qBAAqB,CAACe,IAAtB,CAA2Bd,YAA3B;AACAA,MAAAA,YAAY,GAAG,CAAf;AACD;AACF;;AACD,QAAMe,gBAAgB,GAAGC,IAAI,CAACC,GAAL,CAASC,KAAT,CAAe,IAAf,EAAqBnB,qBAArB,CAAzB;AACAqB,EAAAA,mBAAmB,CAACL,gBAAD,CAAnB;AACD,CA/BM","sourcesContent":["import moment from 'moment';\n\nexport const currentRunStreakCalc = (response, setRunStreak) => {\n  let longestRunStreakArray = [];\n  let oneRunStreak = 0;\n  const currentTime = moment().unix()\n\n  for(let i = 0; i < response.data.length; i++) {\n    if (response.data[i+1] !== undefined) { \n      // oneRunStreak = 1;\n      const prevUpdated = Date.parse(response.data[i].updatedAt)\n      const currentUpdated = Date.parse(response.data[i+1].updatedAt)\n\n      if (prevUpdated !== Date.parse(response.data[i].createdAt)) {\n        if(currentTime - prevUpdated < 86400) { //defines current run streak: within the day\n            if(currentUpdated - prevUpdated < 86400 && response.data[i].completed === true) {\n              //for every session completed in a 24hr window, add 1 to the runStreak. \n              oneRunStreak++;\n            } else {\n              //else break the run streak, push it to array, and start again at 1.\n              longestRunStreakArray.push(oneRunStreak);\n              oneRunStreak = 0;\n            }\n        }  \n      }\n\n    } else {\n      if(response.data[i].completed === true ) {\n        oneRunStreak++;\n      }\n      longestRunStreakArray.push(oneRunStreak);\n      oneRunStreak = 0;\n    }\n\n  }\n\n  const highestRunStreak = Math.max.apply(null, longestRunStreakArray);\n  setRunStreak(highestRunStreak);\n}\n\n//check if working\nexport const longestRunStreakCalc = (response, setLongestRunStreak) => {\n  let longestRunStreakArray = [];\n  let oneRunStreak = 0;\n\n  for(let i = 0; i < response.data.length; i++) {\n    if(response.data[i+1] !== undefined ) {\n      const prevUpdated = Date.parse(response.data[i].updatedAt)\n      const currentUpdated = Date.parse(response.data[i+1].updatedAt)\n\n      if (prevUpdated !== Date.parse(response.data[i].createdAt)) {\n        if(currentUpdated - prevUpdated < 86400) {\n          //seconds 24hrs = 24 * 60 minues * 60 seconds = 86,400 seconds\n          //for every session completed in a 24hr window, add 1 to the runStreak. \n          oneRunStreak++;\n        } else {\n          //else break the run streak, push it to array, and start again at 1.\n          longestRunStreakArray.push(oneRunStreak);\n          oneRunStreak = 1;\n        }\n      }\n\n    } else {\n      if(response.data[i].completed === true ) {\n        oneRunStreak++;\n      }\n      longestRunStreakArray.push(oneRunStreak);\n      oneRunStreak = 0;\n    }\n  }\n  const highestRunStreak = Math.max.apply(null, longestRunStreakArray);\n  setLongestRunStreak(highestRunStreak);\n}"]},"metadata":{},"sourceType":"module"}